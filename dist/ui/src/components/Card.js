"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Card;
const React = require("react");
const react_1 = require("react");
require("../index.css");
const snippetDefinitions_1 = require("../../../snippetDefinitions");
function Card() {
    const [blocks, setBlocks] = (0, react_1.useState)([]);
    const [snippets, setSnippets] = (0, react_1.useState)([]);
    const [autoGenerated, setAutoGenerated] = (0, react_1.useState)(false);
    const [draggedId, setDraggedId] = (0, react_1.useState)(null);
    // Get available block types from snippet definitions
    const componentTypes = Object.keys(snippetDefinitions_1.snippetDefinitions).map(type => ({
        type,
        canBeParent: type === 'Layout' || type === 'NavTabs' || type === 'TabWrapper' || type === 'TabPage' || type === 'Field' || type === 'ConBlock' || type === 'Gate' || type === 'GateGroup',
        label: type
    }));
    (0, react_1.useEffect)(() => {
        // Listen for messages from VS Code extension
        const handleMessage = (event) => {
            const message = event.data;
            if (message.command === 'insertSnippet') {
                // Check if this is from reading Astro files (auto-generated components)
                if (message.tool !== 'tool1' && message.tool !== 'tool2') {
                    // Parse and convert to blocks instead of HTML snippets
                    if (message.parsedComponents && Array.isArray(message.parsedComponents)) {
                        loadDataIntoBlocks(message.parsedComponents);
                        setAutoGenerated(true);
                    }
                    else {
                        // Try to parse from content if parsedComponents not available
                        try {
                            const parsedData = parseAstroContentToBlocks(message.content, message.tool);
                            if (parsedData.length > 0) {
                                loadDataIntoBlocks(parsedData);
                                setAutoGenerated(true);
                            }
                            else {
                                // Fallback to snippet if parsing fails
                                addLegacySnippet(message);
                            }
                        }
                        catch (error) {
                            console.warn('Failed to parse Astro content to blocks:', error);
                            addLegacySnippet(message);
                        }
                    }
                }
                else {
                    // Legacy snippet support for tool1 and tool2
                    addLegacySnippet(message);
                }
            }
            else if (message.command === 'loadBlocks') {
                // Load block data into the editor
                if (message.data && Array.isArray(message.data)) {
                    loadDataIntoBlocks(message.data);
                }
            }
            else if (message.command === 'createBlock') {
                // Create a specific block type from sidebar
                if (message.blockType) {
                    addBlock(message.blockType);
                }
            }
        };
        const addLegacySnippet = (message) => {
            const newSnippet = {
                id: Date.now().toString() + Math.random().toString(36),
                content: message.content,
                tool: message.tool
            };
            setSnippets(prev => [...prev, newSnippet]);
        };
        window.addEventListener('message', handleMessage);
        return () => window.removeEventListener('message', handleMessage);
    }, []);
    // Parse Astro content into blocks
    const parseAstroContentToBlocks = (content, tool) => {
        try {
            // Remove HTML wrapper and extract component structure
            const cleanContent = content.replace(/<\/?div[^>]*>/g, '').trim();
            if (!cleanContent)
                return [];
            const blocks = [];
            // Parse based on the tool/source type
            if (tool.includes('Layout') || tool.includes('.astro')) {
                // Try to identify component patterns in the content
                const componentMatches = cleanContent.match(/<(\w+)([^>]*)>/g) || [];
                componentMatches.forEach(match => {
                    const tagMatch = match.match(/<(\w+)([^>]*)>/);
                    if (tagMatch) {
                        const componentType = tagMatch[1];
                        const attributeString = tagMatch[2];
                        // Check if this is one of our known components
                        if (snippetDefinitions_1.snippetDefinitions[componentType]) {
                            const attributes = parseAttributeString(attributeString);
                            blocks.push({
                                type: componentType,
                                attributes,
                                children: []
                            });
                        }
                    }
                });
            }
            // If no specific parsing worked, try to create a generic block based on content
            if (blocks.length === 0) {
                // Look for any recognizable component names in content
                Object.keys(snippetDefinitions_1.snippetDefinitions).forEach(componentType => {
                    if (cleanContent.includes(componentType)) {
                        blocks.push({
                            type: componentType,
                            attributes: {},
                            children: []
                        });
                    }
                });
            }
            return blocks;
        }
        catch (error) {
            console.warn('Error parsing Astro content:', error);
            return [];
        }
    };
    // Parse HTML attributes string into object
    const parseAttributeString = (attrString) => {
        const attributes = {};
        if (!attrString.trim())
            return attributes;
        // Simple regex to parse attributes like id="value" class="value"
        const attrRegex = /(\w+)=["']([^"']*)["']/g;
        let match;
        while ((match = attrRegex.exec(attrString)) !== null) {
            attributes[match[1]] = match[2];
        }
        // Handle boolean attributes (attributes without values)
        const booleanRegex = /\s+(\w+)(?=\s|$)/g;
        while ((match = booleanRegex.exec(attrString)) !== null) {
            if (!attributes[match[1]]) {
                attributes[match[1]] = 'true';
            }
        }
        return attributes;
    };
    // Block management functions
    const addBlock = (type) => {
        var _a;
        const def = snippetDefinitions_1.snippetDefinitions[type];
        if (!def)
            return;
        const newBlock = {
            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
            type,
            canBeParent: ((_a = componentTypes.find(c => c.type === type)) === null || _a === void 0 ? void 0 : _a.canBeParent) || false,
            children: [],
            attributes: getDefaultAttributes(type, def.attributes)
        };
        setBlocks(prev => [...prev, newBlock]);
    };
    // Generate default attributes based on snippet definition
    const getDefaultAttributes = (type, attrDef) => {
        const attributes = {};
        if (typeof attrDef === 'object' && attrDef !== null) {
            Object.entries(attrDef).forEach(([key, config]) => {
                if (typeof config === 'object' && config.value !== undefined) {
                    attributes[key] = config.value;
                }
                else if (typeof config === 'string') {
                    // Handle cases like NavTabs where attributes is just a string
                    attributes.value = '';
                }
            });
        }
        return attributes;
    };
    // Tree manipulation functions
    const findAndRemove = (list, id, cb) => {
        return list
            .map(block => {
            if (block.id === id) {
                cb(block);
                return null;
            }
            if (block.children.length > 0) {
                return Object.assign(Object.assign({}, block), { children: findAndRemove(block.children, id, cb) });
            }
            return block;
        })
            .filter(Boolean);
    };
    const findAndAdd = (list, parentId, item) => {
        return list.map(block => {
            if (block.id === parentId && block.canBeParent) {
                return Object.assign(Object.assign({}, block), { children: [...block.children, item] });
            }
            if (block.children.length > 0) {
                return Object.assign(Object.assign({}, block), { children: findAndAdd(block.children, parentId, item) });
            }
            return block;
        });
    };
    const onDropOnto = (parentId) => {
        if (!draggedId || draggedId === parentId)
            return;
        let moveBlock = null;
        const without = findAndRemove(blocks, draggedId, b => (moveBlock = b));
        if (moveBlock) {
            setBlocks(findAndAdd(without, parentId, moveBlock));
        }
        setDraggedId(null);
    };
    const deleteBlock = (id) => {
        setBlocks(findAndRemove(blocks, id, () => { }));
    };
    // Update block attributes
    const updateBlockAttribute = (blockId, attributeName, value) => {
        const updateInList = (list) => {
            return list.map(block => {
                if (block.id === blockId) {
                    return Object.assign(Object.assign({}, block), { attributes: Object.assign(Object.assign({}, block.attributes), { [attributeName]: value }) });
                }
                if (block.children.length > 0) {
                    return Object.assign(Object.assign({}, block), { children: updateInList(block.children) });
                }
                return block;
            });
        };
        setBlocks(updateInList);
    };
    // Load data into blocks (when reading existing data)
    const loadDataIntoBlocks = (parsedData) => {
        // Convert parsed data into blocks
        const convertToBlocks = (items) => {
            return items.map(item => {
                var _a;
                const blockType = item.type || 'Layout';
                const def = snippetDefinitions_1.snippetDefinitions[blockType];
                if (!def) {
                    console.warn(`Unknown block type: ${blockType}`);
                    return null;
                }
                const block = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    type: blockType,
                    canBeParent: ((_a = componentTypes.find(c => c.type === blockType)) === null || _a === void 0 ? void 0 : _a.canBeParent) || false,
                    children: item.children ? convertToBlocks(item.children) : [],
                    attributes: item.attributes || {}
                };
                return block;
            }).filter(Boolean);
        };
        const newBlocks = convertToBlocks(parsedData);
        setBlocks(prev => [...prev, ...newBlocks]);
        console.log('Loaded blocks:', newBlocks);
    };
    const clearAllSnippets = () => {
        setSnippets([]);
        setBlocks([]);
    };
    const removeSnippet = (id) => {
        setSnippets(prev => prev.filter(snippet => snippet.id !== id));
    };
    return (React.createElement("div", { className: 'mainCanvas' },
        React.createElement("div", { style: { padding: '20px' } },
            React.createElement("h1", null, "Astro Code Generator"),
            React.createElement("p", null, "Create blocks based on your snippet definitions!"),
            React.createElement("div", { style: {
                    backgroundColor: '#f8f9fa',
                    padding: '16px',
                    borderRadius: '8px',
                    marginBottom: '20px',
                    border: '1px solid #e9ecef'
                } },
                React.createElement("h3", { style: { margin: '0 0 12px 0', fontSize: '16px', color: '#495057' } }, "Add Components:"),
                React.createElement("div", { style: { display: 'flex', flexWrap: 'wrap', gap: '8px' } }, componentTypes.map(c => (React.createElement("button", { key: c.type, onClick: () => addBlock(c.type), style: {
                        padding: '6px 12px',
                        backgroundColor: '#007bff',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '12px',
                        fontWeight: '500'
                    } },
                    "+ ",
                    c.label))))),
            autoGenerated && snippets.length > 0 && (React.createElement("div", { style: {
                    border: '2px solid #28a745',
                    borderRadius: '8px',
                    padding: '12px',
                    marginBottom: '20px',
                    background: 'linear-gradient(45deg, #28a74508, #ffffff08)'
                } },
                React.createElement("div", { style: {
                        fontSize: '12px',
                        color: '#28a745',
                        fontWeight: 'bold'
                    } }, "\uD83C\uDFAF Auto-Generated from Astro Code Analysis"),
                React.createElement("div", { style: { fontSize: '11px', color: '#666', marginTop: '4px' } }, "Components detected and injected automatically in correct order"))),
            (blocks.length > 0 || snippets.length > 0) && (React.createElement("div", { style: { marginBottom: '20px' } },
                React.createElement("button", { onClick: clearAllSnippets, style: {
                        padding: '8px 16px',
                        backgroundColor: '#dc3545',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                    } }, "Clear All"))),
            blocks.length > 0 && (React.createElement("div", { style: {
                    backgroundColor: '#ffffff',
                    padding: '20px',
                    borderRadius: '8px',
                    marginBottom: '20px',
                    border: '1px solid #dee2e6',
                    minHeight: '200px'
                } },
                React.createElement("h3", { style: { margin: '0 0 16px 0', fontSize: '16px', color: '#495057' } }, "Block Editor:"),
                React.createElement("div", { style: { display: 'flex', flexDirection: 'column', gap: '8px' } }, blocks.map(block => (React.createElement(BlockEditor, { key: block.id, block: block, snippetDef: snippetDefinitions_1.snippetDefinitions[block.type], setDraggedId: setDraggedId, draggedId: draggedId, onDropOnto: onDropOnto, onDelete: deleteBlock, onUpdateAttribute: updateBlockAttribute, level: 0 })))))),
            React.createElement("div", { className: "snippets-container" }, snippets.map((snippet) => (React.createElement("div", { key: snippet.id, style: {
                    position: 'relative',
                    marginBottom: '10px',
                    border: '1px solid #ddd',
                    borderRadius: '8px',
                    overflow: 'hidden'
                } },
                React.createElement("div", { style: {
                        backgroundColor: '#f5f5f5',
                        padding: '8px 12px',
                        fontSize: '12px',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                    } },
                    React.createElement("span", null,
                        "Generated from: ",
                        snippet.tool),
                    React.createElement("button", { onClick: () => removeSnippet(snippet.id), style: {
                            background: 'none',
                            border: 'none',
                            cursor: 'pointer',
                            fontSize: '16px'
                        } }, "\u2715")),
                React.createElement("div", { dangerouslySetInnerHTML: { __html: snippet.content } }))))),
            blocks.length === 0 && snippets.length === 0 && (React.createElement("div", { style: {
                    textAlign: 'center',
                    padding: '40px',
                    color: '#666',
                    border: '2px dashed #ddd',
                    borderRadius: '8px',
                    marginTop: '20px'
                } }, "No blocks yet. Click a component button above to start building!")))));
}
// Block Editor Component with automatic input generation
function BlockEditor({ block, snippetDef, setDraggedId, draggedId, onDropOnto, onDelete, onUpdateAttribute, level }) {
    const isBeingDragged = draggedId === block.id;
    const canAcceptDrop = block.canBeParent && draggedId && draggedId !== block.id;
    const [expanded, setExpanded] = (0, react_1.useState)(false);
    // Generate input fields based on attribute definitions
    const renderAttributeInputs = () => {
        if (!(snippetDef === null || snippetDef === void 0 ? void 0 : snippetDef.attributes))
            return null;
        const attrs = snippetDef.attributes;
        // Handle special case where attributes is just a single config (like NavTabs)
        if (typeof attrs === 'object' && attrs.type && attrs.value !== undefined) {
            return (React.createElement("div", { style: { padding: '8px', borderTop: '1px solid #eee' } },
                React.createElement("label", { style: { display: 'block', fontSize: '12px', fontWeight: '500', marginBottom: '4px' } }, "Content:"),
                attrs.type === 'textarea' ? (React.createElement("textarea", { value: block.attributes.value || '', onChange: (e) => onUpdateAttribute(block.id, 'value', e.target.value), required: attrs.requierd, style: {
                        width: '100%',
                        minHeight: '60px',
                        padding: '4px 8px',
                        border: '1px solid #ccc',
                        borderRadius: '4px',
                        fontSize: '12px'
                    } })) : (React.createElement("input", { type: attrs.type || 'text', value: block.attributes.value || '', onChange: (e) => onUpdateAttribute(block.id, 'value', e.target.value), required: attrs.requierd, style: {
                        width: '100%',
                        padding: '4px 8px',
                        border: '1px solid #ccc',
                        borderRadius: '4px',
                        fontSize: '12px'
                    } }))));
        }
        // Handle normal attribute objects
        return (React.createElement("div", { style: { padding: '8px', borderTop: '1px solid #eee' } },
            React.createElement("div", { style: { display: 'grid', gap: '8px' } }, Object.entries(attrs).map(([attrName, config]) => {
                if (typeof config !== 'object' || !config.type)
                    return null;
                return (React.createElement("div", { key: attrName },
                    React.createElement("label", { style: {
                            display: 'block',
                            fontSize: '12px',
                            fontWeight: '500',
                            marginBottom: '2px',
                            color: config.requierd ? '#dc3545' : '#495057'
                        } },
                        attrName,
                        config.requierd ? ' *' : '',
                        ":"),
                    config.type === 'textarea' ? (React.createElement("textarea", { value: block.attributes[attrName] || '', onChange: (e) => onUpdateAttribute(block.id, attrName, e.target.value), required: config.requierd, style: {
                            width: '100%',
                            minHeight: '50px',
                            padding: '4px 8px',
                            border: '1px solid #ccc',
                            borderRadius: '4px',
                            fontSize: '11px'
                        } })) : config.type === 'checkbox' ? (React.createElement("input", { type: "checkbox", checked: block.attributes[attrName] === 'true' || block.attributes[attrName] === true, onChange: (e) => onUpdateAttribute(block.id, attrName, e.target.checked.toString()), style: {
                            marginLeft: '4px'
                        } })) : (React.createElement("input", { type: config.type || 'text', value: block.attributes[attrName] || '', onChange: (e) => onUpdateAttribute(block.id, attrName, e.target.value), required: config.requierd, style: {
                            width: '100%',
                            padding: '4px 8px',
                            border: '1px solid #ccc',
                            borderRadius: '4px',
                            fontSize: '11px'
                        } }))));
            }))));
    };
    return (React.createElement("div", { style: {
            border: `2px solid ${isBeingDragged ? '#6c757d' : canAcceptDrop ? '#007bff' : '#dee2e6'}`,
            borderRadius: '6px',
            backgroundColor: isBeingDragged ? '#f8f9fa' : canAcceptDrop ? '#e7f3ff' : '#ffffff',
            marginLeft: level * 16,
            marginBottom: '4px',
            opacity: isBeingDragged ? 0.5 : 1,
            transition: 'all 0.2s ease'
        } },
        React.createElement("div", { draggable: true, onDragStart: (e) => {
                e.stopPropagation();
                setDraggedId(block.id);
            }, onDragEnd: (e) => {
                e.stopPropagation();
                setDraggedId(null);
            }, onDragOver: (e) => {
                if (block.canBeParent && draggedId && draggedId !== block.id) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, onDrop: (e) => {
                if (block.canBeParent && draggedId && draggedId !== block.id) {
                    onDropOnto(block.id);
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, style: {
                padding: '8px 12px',
                cursor: 'move',
                backgroundColor: '#f8f9fa',
                borderBottom: '1px solid #dee2e6'
            } },
            React.createElement("div", { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between' } },
                React.createElement("div", { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                    React.createElement("span", { style: {
                            backgroundColor: getTypeColor(block.type),
                            color: 'white',
                            padding: '2px 6px',
                            borderRadius: '3px',
                            fontSize: '10px',
                            fontWeight: '600'
                        } }, block.type),
                    React.createElement("span", { style: { fontSize: '12px', color: '#6c757d' } }, getBlockLabel(block)),
                    Object.keys((snippetDef === null || snippetDef === void 0 ? void 0 : snippetDef.attributes) || {}).length > 0 && (React.createElement("button", { onClick: (e) => {
                            e.stopPropagation();
                            setExpanded(!expanded);
                        }, style: {
                            background: 'none',
                            border: 'none',
                            cursor: 'pointer',
                            fontSize: '12px',
                            color: '#007bff'
                        } },
                        expanded ? '▼' : '▶',
                        " Edit"))),
                React.createElement("button", { onClick: (e) => {
                        e.stopPropagation();
                        onDelete(block.id);
                    }, style: {
                        background: 'none',
                        border: 'none',
                        cursor: 'pointer',
                        color: '#dc3545',
                        fontSize: '14px'
                    } }, "\u2715")),
            block.canBeParent && (React.createElement("div", { style: { fontSize: '10px', color: '#6c757d', marginTop: '4px' } }, block.children.length === 0 ? 'Drop components here' : `${block.children.length} children`))),
        expanded && renderAttributeInputs(),
        block.canBeParent && block.children.length > 0 && (React.createElement("div", { style: { paddingLeft: '12px', paddingBottom: '8px' } }, block.children.map(child => (React.createElement(BlockEditor, { key: child.id, block: child, snippetDef: snippetDefinitions_1.snippetDefinitions[child.type], setDraggedId: setDraggedId, draggedId: draggedId, onDropOnto: onDropOnto, onDelete: onDelete, onUpdateAttribute: onUpdateAttribute, level: level + 1 })))))));
}
// Helper functions
function getTypeColor(type) {
    const colors = {
        Layout: '#6f42c1',
        NavTabs: '#fd7e14',
        TabWrapper: '#20c997',
        TabPage: '#17a2b8',
        Field: '#28a745',
        Input: '#007bff',
        Select: '#6610f2',
        Gatekeeper: '#e83e8c',
        Gate: '#ffc107',
        GateGroup: '#dc3545',
        SQL_Select: '#343a40',
        Suggestion: '#6c757d',
        textField: '#fd7e14',
        ConBlock: '#20c997',
        RecordBtn: '#17a2b8',
        FinishBtn: '#28a745',
        NextPageBtn: '#007bff'
    };
    return colors[type] || '#6c757d';
}
function getBlockLabel(block) {
    if (block.attributes.label)
        return block.attributes.label;
    if (block.attributes.id)
        return `#${block.attributes.id}`;
    if (block.attributes.title)
        return block.attributes.title;
    return 'Unnamed';
}
